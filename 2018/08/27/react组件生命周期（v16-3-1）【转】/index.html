<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="xiaofei.wang"><title>【转】react组件生命周期（v16.3.1） · 王小飞的个人博客</title><meta name="description" content="在每个react组件中都有以下几个生命周期方法~我们需要在不同阶段进行讨论
组件生命周期概述1.初始化在组件初始化阶段会执行

constructor
static getDerivedStateFromProps()
componentWillMount() / UNSAFE_componentW"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">王小飞的个人博客</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>【转】react组件生命周期（v16.3.1）</a></h3></div><div class="post-content"><p>在每个react组件中都有以下几个生命周期方法~我们需要在不同阶段进行讨论</p>
<h2 id="组件生命周期概述"><a href="#组件生命周期概述" class="headerlink" title="组件生命周期概述"></a>组件生命周期概述</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p>在组件初始化阶段会执行</p>
<ol>
<li><code>constructor</code></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>componentWillMount()</code> / <code>UNSAFE_componentWillMount()</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ol>
<h3 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2.更新阶段"></a>2.更新阶段</h3><p><code>props</code>或<code>state</code>的改变可能会引起组件的更新，组件重新渲染的过程中会调用以下方法：</p>
<ol>
<li><code>componentWillReceiveProps()</code> / <code>UNSAFE_componentWillReceiveProps()</code></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>componentWillUpdate()</code> / <code>UNSAFE_componentWillUpdate()</code></li>
<li><code>render()</code></li>
<li><code>getSnapshotBeforeUpdate()</code></li>
<li><code>componentDidUpdate()</code></li>
</ol>
<h3 id="3-卸载阶段"><a href="#3-卸载阶段" class="headerlink" title="3.卸载阶段"></a>3.卸载阶段</h3><ol>
<li><code>componentWillUnmount()</code></li>
</ol>
<h3 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4.错误处理"></a>4.错误处理</h3><ol>
<li><code>componentDidCatch()</code></li>
</ol>
<h2 id="react生命周期图示"><a href="#react生命周期图示" class="headerlink" title="react生命周期图示"></a>react生命周期图示</h2><p><img src="http://chuantu.biz/t6/277/1523169546x-1404775659.png" alt="react生命周期图示"></p>
<p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">交互式展示</a></p>
<h2 id="生命周期函数详解"><a href="#生命周期函数详解" class="headerlink" title="生命周期函数详解"></a>生命周期函数详解</h2><h3 id="1-constructor-props"><a href="#1-constructor-props" class="headerlink" title="1.constructor(props)"></a>1.constructor(props)</h3><p>react组件的构造函数在挂载之前被调用。在实现<code>React.Component</code>构造函数时，需要先在添加其他内容前，调用<code>super(props)</code>，用来将父组件传来的<code>props</code>绑定到这个类中，使用<code>this.props</code>将会得到。</p>
<p>官方建议不要在<code>constructor</code>引入任何具有副作用和订阅功能的代码，这些应当在<code>componentDidMount()</code>中写入。</p>
<p><code>constructor</code>中应当做些初始化的动作，如：初始化<code>state</code>，将事件处理函数绑定到类实例上，但也不要使用<code>setState()</code>。如果没有必要初始化state或绑定方法，则不需要构造<code>constructor</code>，或者把这个组件换成纯函数写法。</p>
<p>当然也可以利用<code>props</code>初始化<code>state</code>，在之后修改<code>state</code>不会对props造成任何修改，但仍然建议大家提升状态到父组件中，或使用<code>redux</code>统一进行状态管理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    color: props.initialColor</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-static-getDerivedStateFromProps-nextProps-prevState"><a href="#2-static-getDerivedStateFromProps-nextProps-prevState" class="headerlink" title="2.static getDerivedStateFromProps(nextProps, prevState)"></a>2.static getDerivedStateFromProps(nextProps, prevState)</h3><p><code>getDerivedStateFromProps</code>在组件实例化后，和接受新的<code>props</code>后被调用。他返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。</p>
<p>如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。</p>
<p>调用<code>steState()</code>不会触发<code>getDerivedStateFromProps()</code>。</p>
<h3 id="3-componentWillMount-UNSAFE-componentWillMount"><a href="#3-componentWillMount-UNSAFE-componentWillMount" class="headerlink" title="3. componentWillMount() / UNSAFE_componentWillMount()"></a>3. componentWillMount() / UNSAFE_componentWillMount()</h3><p><code>componentWillMount()</code>将在react未来版本中被弃用。<code>UNSAFE_componentWillMount()</code>在组件挂载前被调用，在这个方法中调用<code>setState()</code>不会起作用，是由于他在<code>render()</code>前被调用。</p>
<p>为了避免副作用和其他的订阅，官方都建议使用<code>componentDidMount()</code>代替。这个方法是用于在服务器渲染上的唯一方法。</p>
<h3 id="4-render"><a href="#4-render" class="headerlink" title="4.render()"></a>4.render()</h3><p><code>render()</code>方法是必需的。当他被调用时，他将计算<code>this.props</code>和<code>this.state</code>，并返回以下一种类型：</p>
<ol>
<li>React元素。通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。</li>
<li>字符串或数字。他们将会以文本节点形式渲染到dom中。</li>
<li>Portals。react 16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。</li>
<li><code>null</code>，什么也不渲染</li>
<li>布尔值。也是什么都不渲染，通常后跟组件进行判断。</li>
</ol>
<p>当返回<code>null</code>,<code>false</code>,<code>ReactDOM.findDOMNode(this)</code>将会返回null，什么都不会渲染。</p>
<p><code>render()</code>方法必须是一个纯函数，他不应该改变<code>state</code>，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。<br>如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>render()</code>不会被调用。</p>
<h4 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h4><p>你也可以在<code>render()</code>中使用数组，如：(<em>不要忘记给每个数组元素添加key，防止出现警告</em>)<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &lt;li key=<span class="string">"A"</span>&gt;First item&lt;<span class="regexp">/li&gt;,</span></span><br><span class="line"><span class="regexp">    &lt;li key="B"&gt;Second item&lt;/</span>li&gt;,</span><br><span class="line">    &lt;li key=<span class="string">"C"</span>&gt;Third item&lt;<span class="regexp">/li&gt;,</span></span><br><span class="line"><span class="regexp">  ];</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>换一种写法，可以不写key（v16++）<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;li&gt;First item&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;Second item&lt;/</span>li&gt;</span><br><span class="line">      &lt;li&gt;Third item&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-componentWillReceiveProps-UNSAFE-componentWillReceiveProps-nextProps"><a href="#5-componentWillReceiveProps-UNSAFE-componentWillReceiveProps-nextProps" class="headerlink" title="5.componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)"></a>5.componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)</h3><p>官方建议使用<code>getDerivedStateFromProps</code>函数代替<code>componentWillReceiveProps()</code>。当组件挂载后，接收到新的<code>props</code>后会被调用。如果需要更新<code>state</code>来响应<code>props</code>的更改，则可以进行<code>this.props</code>和<code>nextProps</code>的比较，并在此方法中使用<code>this.setState()</code>。</p>
<p>如果父组件会让这个组件重新渲染，即使<code>props</code>没有改变，也会调用这个方法。</p>
<p>react不会在组件初始化props时调用这个方法。调用<code>this.setState</code>也不会触发。</p>
<h3 id="6-shouldComponentUpdate-nextProps-nextState"><a href="#6-shouldComponentUpdate-nextProps-nextState" class="headerlink" title="6.shouldComponentUpdate(nextProps, nextState)"></a>6.shouldComponentUpdate(nextProps, nextState)</h3><p>调用<code>shouldComponentUpdate</code>使react知道，组件的输出是否受<code>state</code>和<code>props</code>的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。</p>
<p>在渲染新的<code>props</code>或<code>state</code>前，<code>shouldComponentUpdate</code>会被调用。默认为<code>true</code>。这个方法不会在初始化时被调用，也不会在<code>forceUpdate()</code>时被调用。返回<code>false</code>不会阻止子组件在<code>state</code>更改时重新渲染。</p>
<p>如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>componentwillupdate</code>,<code>render</code>和<code>componentDidUpdate</code>不会被调用。</p>
<blockquote>
<p>在未来版本，shouldComponentUpdate()将会作为一个提示而不是严格的指令，返回false仍然可能导致组件的重新渲染。</p>
</blockquote>
<p>官方并不建议在<code>shouldComponentUpdate()</code>中进行深度查询或使用<code>JSON.stringify()</code>，他效率非常低，并且损伤性能。</p>
<h3 id="7-UNSAFE-componentWillUpdate-nextProps-nextState"><a href="#7-UNSAFE-componentWillUpdate-nextProps-nextState" class="headerlink" title="7.UNSAFE_componentWillUpdate(nextProps, nextState)"></a>7.UNSAFE_componentWillUpdate(nextProps, nextState)</h3><p>在渲染新的<code>state</code>或<code>props</code>时，<code>UNSAFE_componentWillUpdate</code>会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。</p>
<p><em>不能在这里使用this.setState()</em>，也不能做会触发视图更新的操作。如果需要更新<code>state</code>或<code>props</code>，调用<code>getDerivedStateFromProps</code>。</p>
<h3 id="8-getSnapshotBeforeUpdate"><a href="#8-getSnapshotBeforeUpdate" class="headerlink" title="8.getSnapshotBeforeUpdate()"></a>8.getSnapshotBeforeUpdate()</h3><p>在react <code>render()</code>后的输出被渲染到DOM之前被调用。它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。</p>
<h3 id="9-componentDidUpdate-prevProps-prevState-snapshot"><a href="#9-componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="9.componentDidUpdate(prevProps, prevState, snapshot)"></a>9.componentDidUpdate(prevProps, prevState, snapshot)</h3><p>在更新发生后立即调用<code>componentDidUpdate()</code>。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。</p>
<p>如果组件实现<code>getSnapshotBeforeUpdate()</code>生命周期，则它返回的值将作为第三个“快照”参数传递给<code>componentDidUpdate()</code>。否则，这个参数是<code>undefined</code>。</p>
<h3 id="10-componentWillUnmount"><a href="#10-componentWillUnmount" class="headerlink" title="10.componentWillUnmount()"></a>10.componentWillUnmount()</h3><p>在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在componentDidMount（）中创建的任何监听。</p>
<h3 id="11-componentDidCatch-error-info"><a href="#11-componentDidCatch-error-info" class="headerlink" title="11.componentDidCatch(error, info)"></a>11.componentDidCatch(error, info)</h3><p><em>错误边界</em>是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。</p>
<p>如果类组件定义了此生命周期方法，则它将成为<em>错误边界</em>。在它中调用<code>setState()</code>可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复;不要试图将它们用于控制流程。<a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">详细</a></p>
<p>错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html#component-lifecycle-changes" target="_blank" rel="noopener">React v16.3.0: New lifecycles and context API</a></li>
<li><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React.Component</a></li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-08-27</span><i class="fa fa-tag"></i><a class="tag" href="/tags/react-lifecycle/" title="react lifecycle">react lifecycle </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://wangxiaofeid.github.io/2018/08/27/react组件生命周期（v16-3-1）【转】/,王小飞的个人博客,【转】react组件生命周期（v16.3.1）,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/09/04/react生命周期执行顺序测试/" title="react生命周期执行顺序测试">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/08/01/奇妙的算法/" title="有趣的算法">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>